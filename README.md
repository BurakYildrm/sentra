# Sentra - Admin Panel with RBAC

A modern, full-stack admin panel built with Next.js 15, featuring role-based access control (RBAC), comprehensive user and article management, and a beautiful UI built with shadcn/ui and Tailwind CSS.

## 🚀 Features

- **Authentication**: Supabase auth with protected routes
- **RBAC**: Admin, Editor, and Viewer roles with granular permissions
- **User Management**: CRUD operations with role assignment
- **Article Management**: Content creation and editing with validation
- **UI**: Responsive design with dark/light theme using shadcn/ui
- **Data Tables**: Sortable, filterable tables with loading states

## 🛠️ Tech Stack

### Frontend

- **Next.js 15** - React framework with App Router
- **React 19** - Latest React with concurrent features
- **TypeScript** - Type-safe development
- **Tailwind CSS** - Utility-first CSS framework
- **shadcn/ui** - Accessible component primitives
- **React Hook Form** - Performant form handling
- **Zod** - Schema validation
- **Recharts** - Data visualization
- **Lucide React** - Beautiful icons

### Backend & Database

- **Supabase** - Backend-as-a-Service
- **PostgreSQL** - Relational database
- **Row Level Security (RLS)** - Database-level security
- **Server Actions** - Next.js server-side functions

### Development & Testing

- **Vitest** - Fast unit testing
- **ESLint** - Code linting
- **Prettier** - Code formatting
- **pnpm** - Fast package manager

## 📁 Project Structure

```
src/
├── app/                    # Next.js App Router
│   ├── (private)/         # Protected routes
│   │   ├── articles/      # Article management pages
│   │   ├── users/         # User management pages
│   │   └── layout.tsx     # Private layout with sidebar
│   └── (public)/          # Public routes
│       └── login/         # Authentication pages
├── components/            # React components
│   ├── features/          # Feature-specific components
│   │   ├── article/       # Article management components
│   │   ├── auth/          # Authentication components
│   │   ├── home/          # Dashboard components
│   │   └── user/          # User management components
│   ├── layout/            # Layout components
│   └── ui/                # Reusable UI components
├── lib/                   # Core business logic
│   ├── article-core.ts    # Article business logic
│   ├── auth-core.ts       # Authentication business logic
│   ├── user-core.ts       # User business logic
│   └── shared.ts          # Shared utilities
├── actions/               # Server actions
│   ├── article-actions.ts # Article server actions
│   ├── auth-actions.ts    # Authentication server actions
│   └── user-actions.ts    # User server actions
├── types/                 # TypeScript type definitions
├── utils/                 # Utility functions
└── __tests__/             # Test files
```

## 🚀 Getting Started

### Prerequisites

- Node.js 18.x or higher
- pnpm (recommended) or npm
- Supabase account

### Installation

1. **Clone the repository**

   ```bash
   git clone https://github.com/BurakYildrm/sentra.git
   cd sentra
   ```

2. **Install dependencies**

   ```bash
   pnpm install
   ```

3. **Set up environment variables**

   ```env
   NEXT_PUBLIC_SUPABASE_URL=your_supabase_url
   NEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key
   SUPABASE_SERVICE_ROLE_KEY=your_service_role_key
   ```

4. **Set up the database**
   - Create a new Supabase project
   - Run the SQL migrations (see Database Setup section)
   - Configure Row Level Security policies

5. **Start the development server**

   ```bash
   pnpm dev
   ```

## 🗄️ Database Setup

### Schema Creation

```sql
-- Custom types
create type public.app_permission as enum ('users.insert', 'users.update', 'users.delete', 'articles.insert', 'articles.update', 'articles.delete');
create type public.app_role as enum ('admin', 'editor', 'viewer');

-- USERS
create table public.users (
  id          uuid references auth.users not null primary key, -- UUID from auth.users
  username    text
);

-- USER ROLES
create table public.user_roles (
  id        bigint generated by default as identity primary key,
  user_id   uuid references public.users on delete cascade not null,
  role      app_role not null,
  unique (user_id, role)
);

-- ROLE PERMISSIONS
create table public.role_permissions (
  id           bigint generated by default as identity primary key,
  role         app_role not null,
  permission   app_permission not null,
  unique (role, permission)
);

-- ARTICLES
create table if not exists public.articles (
  id          uuid primary key default gen_random_uuid(),
  title       text not null,
  content     text not null,
  created_at  timestamptz not null default now(),
  updated_at  timestamptz not null default now()
);
```

### Authorization Functions

```sql
-- authorize with role-based access control (RBAC)
create function public.authorize(
  requested_permission app_permission
)
returns boolean as $$
declare
  bind_permissions int;
begin
  select count(*)
  from public.role_permissions
  where role_permissions.permission = authorize.requested_permission
    and role_permissions.role = (auth.jwt() ->> 'user_role')::public.app_role
  into bind_permissions;

  return bind_permissions > 0;
end;
$$ language plpgsql security definer set search_path = public;

-- Grant permissions helper function
create or replace function public.grant_permissions(
  r public.app_role,
  perms public.app_permission[]
) returns void language sql as $$
  insert into public.role_permissions (role, permission)
  select r, unnest(perms)
  on conflict (role, permission) do nothing;
$$;

-- Get table permissions for frontend
create or replace function public.get_table_permissions(p_table text)
returns text[]
language sql
stable
security definer
set search_path = public
as $$
  with my_role as (
    select nullif(auth.jwt()->>'user_role','')::public.app_role as role
  ),
  perms as (
    select distinct split_part(rp.permission::text, '.', 2) as action
    from public.role_permissions rp, my_role mr
    where mr.role is not null
      and rp.role = mr.role
      and split_part(rp.permission::text, '.', 1) = lower(trim(p_table))
  )
  select coalesce(array_agg(action order by action), '{}') from perms;
$$;
```

### Auth Hook

```sql
-- Custom access token hook for JWT claims
create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb
language plpgsql
stable
as $$
  declare
    claims jsonb;
    user_role public.app_role;
  begin
    -- Check if the user has a role in the user_roles table
    select role into user_role from public.user_roles where user_id = (event->>'user_id')::uuid;

    claims := event->'claims';

    if user_role is not null then
      -- Set the claim
      claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    else
      claims := jsonb_set(claims, '{user_role}', 'null');
    end if;

    -- Update the 'claims' object in the original event
    event := jsonb_set(event, '{claims}', claims);

    -- Return the modified or original event
    return event;
  end;
$$;
```

### Row Level Security Policies

```sql
-- Enable RLS
alter table public.users enable row level security;
alter table public.user_roles enable row level security;
alter table public.role_permissions enable row level security;
alter table public.articles enable row level security;

-- Users policies
create policy "Allow logged-in read access" on public.users for select using ( auth.role() = 'authenticated' );
create policy "Allow authorized insert access" on public.users for insert with check ( authorize('users.insert') );
create policy "Allow authorized update access" on public.users for update using ( authorize('users.update') );
create policy "Allow authorized delete access" on public.users for delete using ( authorize('users.delete') );

-- User roles policies
create policy "Allow logged-in read access" on public.user_roles for select using ( auth.role() = 'authenticated' );
create policy "Allow authorized insert access" on public.user_roles for insert with check ( authorize('users.insert') );
create policy "Allow authorized update access" on public.user_roles for update using ( authorize('users.update') );
create policy "Allow authorized delete access" on public.user_roles for delete using ( authorize('users.delete') );

-- Role permissions policies
create policy "Allow logged-in read access" on public.role_permissions for select using ( auth.role() = 'authenticated' );

-- Articles policies
create policy "Allow logged-in read access" on public.articles for select using ( auth.role() = 'authenticated' );
create policy "Allow authorized insert access" on public.articles for insert with check ( authorize('articles.insert') );
create policy "Allow authorized update access" on public.articles for update using ( authorize('articles.update') );
create policy "Allow authorized delete access" on public.articles for delete using ( authorize('articles.delete') );
```

### Auto-update Trigger

```sql
-- Auto-update updated_at for articles
create extension if not exists moddatetime schema extensions;

drop trigger if exists articles_handle_updated_at on public.articles;
create trigger articles_handle_updated_at
before update on public.articles
for each row
execute procedure extensions.moddatetime(updated_at);
```

### Initial Permissions Setup

```sql
-- Grant permissions to roles
select public.grant_permissions('admin', array['users.insert','users.update','users.delete','articles.insert','articles.update','articles.delete']::public.app_permission[]);
select public.grant_permissions('editor', array['users.insert','users.update','articles.insert','articles.update']::public.app_permission[]);

-- Grant necessary permissions
grant usage on schema public to supabase_auth_admin;
grant execute on function public.custom_access_token_hook to supabase_auth_admin;
grant all on table public.user_roles to supabase_auth_admin;
grant execute on function public.get_table_permissions(text) to authenticated;
grant usage on schema public to authenticated;
grant select on public.role_permissions to authenticated;

create policy "Allow auth admin to read user roles" ON public.user_roles
as permissive for select
to supabase_auth_admin
using (true);
```

### Permission System Overview

The application uses Supabase RLS with the `authorize()` function for database-level security:

| Resource       | Admin                        | Editor               | Viewer |
| -------------- | ---------------------------- | -------------------- | ------ |
| **Users**      | Create, Read, Update, Delete | Read                 | Read   |
| **Articles**   | Create, Read, Update, Delete | Create, Read, Update | Read   |
| **User Roles** | Create, Read, Update, Delete | Read                 | Read   |

**Key Features:**

- **JWT Integration**: User roles are embedded in JWT tokens via `custom_access_token_hook`
- **Permission Checking**: `authorize()` function validates permissions against `role_permissions` table
- **Frontend Integration**: `get_table_permissions()` provides permission arrays for UI components
- **Automatic Timestamps**: `moddatetime` extension handles `updated_at` fields

## 🔐 Authorization

Permission checking:

```typescript
type Permission = "insert" | "update" | "delete";
type Can = (action: Permission) => boolean;
function canPerform(perms: Array<Permission>): Can {
  const allowed = new Set(perms ?? []);
  return (action: Permission) => allowed.has(action);
}
```

## 🧪 Testing

```bash
pnpm test                    # Run all tests
pnpm test user-core.test.ts  # Run specific test file
```

## 🎯 Demo

**[Live Demo](https://sentra-ten.vercel.app/)**

| Role   | Email             | Password |
| ------ | ----------------- | -------- |
| Admin  | `admin@test.com`  | `admin`  |
| Editor | `editor@test.com` | `editor` |
| Viewer | `viewer@test.com` | `viewer` |

## 🔧 Development

### Scripts

```bash
pnpm dev     # Start development server
pnpm build   # Build for production
pnpm start   # Start production server
pnpm test    # Run tests
```

### Code Style

The project follows strict code style guidelines:

- **ESLint** for code linting
- **Prettier** for code formatting
- **TypeScript** for type safety

## 📝 License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
